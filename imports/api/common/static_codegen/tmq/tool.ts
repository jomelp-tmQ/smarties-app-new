/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: tmq/tool.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./common";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace tmq {
    export enum ToolParameterType {
        STRING = 0,
        NUMBER = 1,
        BOOLEAN = 2,
        ARRAY = 3,
        OBJECT = 4
    }
    export enum ToolMessageType {
        REQUEST_START = 0,
        REQUEST_COMPLETE = 1,
        REQUEST_FAILED = 2,
        REQUEST_RESPONSE_DELAYED = 3
    }
    export class ToolResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            success?: boolean;
            message?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
            }
        }
        get success() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            success?: boolean;
            message?: string;
        }): ToolResponse {
            const message = new ToolResponse({});
            if (data.success != null) {
                message.success = data.success;
            }
            if (data.message != null) {
                message.message = data.message;
            }
            return message;
        }
        toObject() {
            const data: {
                success?: boolean;
                message?: string;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.message != null) {
                data.message = this.message;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success != false)
                writer.writeBool(1, this.success);
            if (this.message.length)
                writer.writeString(2, this.message);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        message.message = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolResponse {
            return ToolResponse.deserialize(bytes);
        }
    }
    export class ToolParameterProperties extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            type?: ToolParameterType;
            description?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 2, ToolParameterType.STRING) as ToolParameterType;
        }
        set type(value: ToolParameterType) {
            pb_1.Message.setField(this, 2, value);
        }
        get description() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            name?: string;
            type?: ToolParameterType;
            description?: string;
        }): ToolParameterProperties {
            const message = new ToolParameterProperties({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                type?: ToolParameterType;
                description?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.type != ToolParameterType.STRING)
                writer.writeEnum(2, this.type);
            if (this.description.length)
                writer.writeString(3, this.description);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolParameterProperties {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolParameterProperties();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.type = reader.readEnum();
                        break;
                    case 3:
                        message.description = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolParameterProperties {
            return ToolParameterProperties.deserialize(bytes);
        }
    }
    export class ToolParameters extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: ToolParameterType;
            properties?: ToolParameterProperties[];
            required_fields?: string[];
            additionalProperties?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("properties" in data && data.properties != undefined) {
                    this.properties = data.properties;
                }
                if ("required_fields" in data && data.required_fields != undefined) {
                    this.required_fields = data.required_fields;
                }
                if ("additionalProperties" in data && data.additionalProperties != undefined) {
                    this.additionalProperties = data.additionalProperties;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, ToolParameterType.STRING) as ToolParameterType;
        }
        set type(value: ToolParameterType) {
            pb_1.Message.setField(this, 1, value);
        }
        get properties() {
            return pb_1.Message.getRepeatedWrapperField(this, ToolParameterProperties, 2) as ToolParameterProperties[];
        }
        set properties(value: ToolParameterProperties[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get required_fields() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set required_fields(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get additionalProperties() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set additionalProperties(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            type?: ToolParameterType;
            properties?: ReturnType<typeof ToolParameterProperties.prototype.toObject>[];
            required_fields?: string[];
            additionalProperties?: boolean;
        }): ToolParameters {
            const message = new ToolParameters({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.properties != null) {
                message.properties = data.properties.map(item => ToolParameterProperties.fromObject(item));
            }
            if (data.required_fields != null) {
                message.required_fields = data.required_fields;
            }
            if (data.additionalProperties != null) {
                message.additionalProperties = data.additionalProperties;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: ToolParameterType;
                properties?: ReturnType<typeof ToolParameterProperties.prototype.toObject>[];
                required_fields?: string[];
                additionalProperties?: boolean;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.properties != null) {
                data.properties = this.properties.map((item: ToolParameterProperties) => item.toObject());
            }
            if (this.required_fields != null) {
                data.required_fields = this.required_fields;
            }
            if (this.additionalProperties != null) {
                data.additionalProperties = this.additionalProperties;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != ToolParameterType.STRING)
                writer.writeEnum(1, this.type);
            if (this.properties.length)
                writer.writeRepeatedMessage(2, this.properties, (item: ToolParameterProperties) => item.serialize(writer));
            if (this.required_fields.length)
                writer.writeRepeatedString(3, this.required_fields);
            if (this.additionalProperties != false)
                writer.writeBool(4, this.additionalProperties);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolParameters {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolParameters();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.properties, () => pb_1.Message.addToRepeatedWrapperField(message, 2, ToolParameterProperties.deserialize(reader), ToolParameterProperties));
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    case 4:
                        message.additionalProperties = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolParameters {
            return ToolParameters.deserialize(bytes);
        }
    }
    export class ToolHeaders extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key?: string;
            value?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            key?: string;
            value?: string;
        }): ToolHeaders {
            const message = new ToolHeaders({});
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                key?: string;
                value?: string;
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key.length)
                writer.writeString(1, this.key);
            if (this.value.length)
                writer.writeString(2, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolHeaders {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolHeaders();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readString();
                        break;
                    case 2:
                        message.value = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolHeaders {
            return ToolHeaders.deserialize(bytes);
        }
    }
    export class ToolMessages extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: ToolMessageType;
            content?: string;
            conditions?: ToolMessages[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("content" in data && data.content != undefined) {
                    this.content = data.content;
                }
                if ("conditions" in data && data.conditions != undefined) {
                    this.conditions = data.conditions;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, ToolMessageType.REQUEST_START) as ToolMessageType;
        }
        set type(value: ToolMessageType) {
            pb_1.Message.setField(this, 1, value);
        }
        get content() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set content(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get conditions() {
            return pb_1.Message.getRepeatedWrapperField(this, ToolMessages, 3) as ToolMessages[];
        }
        set conditions(value: ToolMessages[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            type?: ToolMessageType;
            content?: string;
            conditions?: ReturnType<typeof ToolMessages.prototype.toObject>[];
        }): ToolMessages {
            const message = new ToolMessages({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.content != null) {
                message.content = data.content;
            }
            if (data.conditions != null) {
                message.conditions = data.conditions.map(item => ToolMessages.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                type?: ToolMessageType;
                content?: string;
                conditions?: ReturnType<typeof ToolMessages.prototype.toObject>[];
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.content != null) {
                data.content = this.content;
            }
            if (this.conditions != null) {
                data.conditions = this.conditions.map((item: ToolMessages) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != ToolMessageType.REQUEST_START)
                writer.writeEnum(1, this.type);
            if (this.content.length)
                writer.writeString(2, this.content);
            if (this.conditions.length)
                writer.writeRepeatedMessage(3, this.conditions, (item: ToolMessages) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolMessages {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolMessages();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        message.content = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.conditions, () => pb_1.Message.addToRepeatedWrapperField(message, 3, ToolMessages.deserialize(reader), ToolMessages));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolMessages {
            return ToolMessages.deserialize(bytes);
        }
    }
    export class ToolServerConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            serverUrl?: string;
            secret?: string;
            timeout?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("serverUrl" in data && data.serverUrl != undefined) {
                    this.serverUrl = data.serverUrl;
                }
                if ("secret" in data && data.secret != undefined) {
                    this.secret = data.secret;
                }
                if ("timeout" in data && data.timeout != undefined) {
                    this.timeout = data.timeout;
                }
            }
        }
        get serverUrl() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set serverUrl(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get secret() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set secret(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get timeout() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set timeout(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            serverUrl?: string;
            secret?: string;
            timeout?: number;
        }): ToolServerConfig {
            const message = new ToolServerConfig({});
            if (data.serverUrl != null) {
                message.serverUrl = data.serverUrl;
            }
            if (data.secret != null) {
                message.secret = data.secret;
            }
            if (data.timeout != null) {
                message.timeout = data.timeout;
            }
            return message;
        }
        toObject() {
            const data: {
                serverUrl?: string;
                secret?: string;
                timeout?: number;
            } = {};
            if (this.serverUrl != null) {
                data.serverUrl = this.serverUrl;
            }
            if (this.secret != null) {
                data.secret = this.secret;
            }
            if (this.timeout != null) {
                data.timeout = this.timeout;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.serverUrl.length)
                writer.writeString(1, this.serverUrl);
            if (this.secret.length)
                writer.writeString(2, this.secret);
            if (this.timeout != 0)
                writer.writeInt32(3, this.timeout);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolServerConfig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolServerConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.serverUrl = reader.readString();
                        break;
                    case 2:
                        message.secret = reader.readString();
                        break;
                    case 3:
                        message.timeout = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolServerConfig {
            return ToolServerConfig.deserialize(bytes);
        }
    }
    export class ToolRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            description?: string;
            parameters?: ToolParameters;
            serverConfig?: ToolServerConfig;
            headers?: ToolHeaders[];
            messages?: ToolMessages[];
            async?: boolean;
            strict?: boolean;
            userId?: string;
            id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5, 6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("parameters" in data && data.parameters != undefined) {
                    this.parameters = data.parameters;
                }
                if ("serverConfig" in data && data.serverConfig != undefined) {
                    this.serverConfig = data.serverConfig;
                }
                if ("headers" in data && data.headers != undefined) {
                    this.headers = data.headers;
                }
                if ("messages" in data && data.messages != undefined) {
                    this.messages = data.messages;
                }
                if ("async" in data && data.async != undefined) {
                    this.async = data.async;
                }
                if ("strict" in data && data.strict != undefined) {
                    this.strict = data.strict;
                }
                if ("userId" in data && data.userId != undefined) {
                    this.userId = data.userId;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get description() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get parameters() {
            return pb_1.Message.getWrapperField(this, ToolParameters, 3) as ToolParameters;
        }
        set parameters(value: ToolParameters) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_parameters() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get serverConfig() {
            return pb_1.Message.getWrapperField(this, ToolServerConfig, 4) as ToolServerConfig;
        }
        set serverConfig(value: ToolServerConfig) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_serverConfig() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get headers() {
            return pb_1.Message.getRepeatedWrapperField(this, ToolHeaders, 5) as ToolHeaders[];
        }
        set headers(value: ToolHeaders[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get messages() {
            return pb_1.Message.getRepeatedWrapperField(this, ToolMessages, 6) as ToolMessages[];
        }
        set messages(value: ToolMessages[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get async() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set async(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        get strict() {
            return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
        }
        set strict(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get userId() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set userId(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            name?: string;
            description?: string;
            parameters?: ReturnType<typeof ToolParameters.prototype.toObject>;
            serverConfig?: ReturnType<typeof ToolServerConfig.prototype.toObject>;
            headers?: ReturnType<typeof ToolHeaders.prototype.toObject>[];
            messages?: ReturnType<typeof ToolMessages.prototype.toObject>[];
            async?: boolean;
            strict?: boolean;
            userId?: string;
            id?: string;
        }): ToolRequest {
            const message = new ToolRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            if (data.parameters != null) {
                message.parameters = ToolParameters.fromObject(data.parameters);
            }
            if (data.serverConfig != null) {
                message.serverConfig = ToolServerConfig.fromObject(data.serverConfig);
            }
            if (data.headers != null) {
                message.headers = data.headers.map(item => ToolHeaders.fromObject(item));
            }
            if (data.messages != null) {
                message.messages = data.messages.map(item => ToolMessages.fromObject(item));
            }
            if (data.async != null) {
                message.async = data.async;
            }
            if (data.strict != null) {
                message.strict = data.strict;
            }
            if (data.userId != null) {
                message.userId = data.userId;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                description?: string;
                parameters?: ReturnType<typeof ToolParameters.prototype.toObject>;
                serverConfig?: ReturnType<typeof ToolServerConfig.prototype.toObject>;
                headers?: ReturnType<typeof ToolHeaders.prototype.toObject>[];
                messages?: ReturnType<typeof ToolMessages.prototype.toObject>[];
                async?: boolean;
                strict?: boolean;
                userId?: string;
                id?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.parameters != null) {
                data.parameters = this.parameters.toObject();
            }
            if (this.serverConfig != null) {
                data.serverConfig = this.serverConfig.toObject();
            }
            if (this.headers != null) {
                data.headers = this.headers.map((item: ToolHeaders) => item.toObject());
            }
            if (this.messages != null) {
                data.messages = this.messages.map((item: ToolMessages) => item.toObject());
            }
            if (this.async != null) {
                data.async = this.async;
            }
            if (this.strict != null) {
                data.strict = this.strict;
            }
            if (this.userId != null) {
                data.userId = this.userId;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.description.length)
                writer.writeString(2, this.description);
            if (this.has_parameters)
                writer.writeMessage(3, this.parameters, () => this.parameters.serialize(writer));
            if (this.has_serverConfig)
                writer.writeMessage(4, this.serverConfig, () => this.serverConfig.serialize(writer));
            if (this.headers.length)
                writer.writeRepeatedMessage(5, this.headers, (item: ToolHeaders) => item.serialize(writer));
            if (this.messages.length)
                writer.writeRepeatedMessage(6, this.messages, (item: ToolMessages) => item.serialize(writer));
            if (this.async != false)
                writer.writeBool(7, this.async);
            if (this.strict != false)
                writer.writeBool(8, this.strict);
            if (this.userId.length)
                writer.writeString(9, this.userId);
            if (this.id.length)
                writer.writeString(10, this.id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.description = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.parameters, () => message.parameters = ToolParameters.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.serverConfig, () => message.serverConfig = ToolServerConfig.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.headers, () => pb_1.Message.addToRepeatedWrapperField(message, 5, ToolHeaders.deserialize(reader), ToolHeaders));
                        break;
                    case 6:
                        reader.readMessage(message.messages, () => pb_1.Message.addToRepeatedWrapperField(message, 6, ToolMessages.deserialize(reader), ToolMessages));
                        break;
                    case 7:
                        message.async = reader.readBool();
                        break;
                    case 8:
                        message.strict = reader.readBool();
                        break;
                    case 9:
                        message.userId = reader.readString();
                        break;
                    case 10:
                        message.id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolRequest {
            return ToolRequest.deserialize(bytes);
        }
    }
    export class FetchToolsRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            userId?: string;
            lastBasis?: number;
            searchQuery?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("userId" in data && data.userId != undefined) {
                    this.userId = data.userId;
                }
                if ("lastBasis" in data && data.lastBasis != undefined) {
                    this.lastBasis = data.lastBasis;
                }
                if ("searchQuery" in data && data.searchQuery != undefined) {
                    this.searchQuery = data.searchQuery;
                }
            }
        }
        get userId() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set userId(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get lastBasis() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set lastBasis(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get searchQuery() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set searchQuery(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            userId?: string;
            lastBasis?: number;
            searchQuery?: string;
        }): FetchToolsRequest {
            const message = new FetchToolsRequest({});
            if (data.userId != null) {
                message.userId = data.userId;
            }
            if (data.lastBasis != null) {
                message.lastBasis = data.lastBasis;
            }
            if (data.searchQuery != null) {
                message.searchQuery = data.searchQuery;
            }
            return message;
        }
        toObject() {
            const data: {
                userId?: string;
                lastBasis?: number;
                searchQuery?: string;
            } = {};
            if (this.userId != null) {
                data.userId = this.userId;
            }
            if (this.lastBasis != null) {
                data.lastBasis = this.lastBasis;
            }
            if (this.searchQuery != null) {
                data.searchQuery = this.searchQuery;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.userId.length)
                writer.writeString(1, this.userId);
            if (this.lastBasis != 0)
                writer.writeInt64(2, this.lastBasis);
            if (this.searchQuery.length)
                writer.writeString(3, this.searchQuery);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FetchToolsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FetchToolsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.userId = reader.readString();
                        break;
                    case 2:
                        message.lastBasis = reader.readInt64();
                        break;
                    case 3:
                        message.searchQuery = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FetchToolsRequest {
            return FetchToolsRequest.deserialize(bytes);
        }
    }
    export class ToolFunction extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            description?: string;
            parameters?: ToolParameters;
            strict?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("parameters" in data && data.parameters != undefined) {
                    this.parameters = data.parameters;
                }
                if ("strict" in data && data.strict != undefined) {
                    this.strict = data.strict;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get description() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get parameters() {
            return pb_1.Message.getWrapperField(this, ToolParameters, 3) as ToolParameters;
        }
        set parameters(value: ToolParameters) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_parameters() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get strict() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set strict(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            name?: string;
            description?: string;
            parameters?: ReturnType<typeof ToolParameters.prototype.toObject>;
            strict?: boolean;
        }): ToolFunction {
            const message = new ToolFunction({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            if (data.parameters != null) {
                message.parameters = ToolParameters.fromObject(data.parameters);
            }
            if (data.strict != null) {
                message.strict = data.strict;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                description?: string;
                parameters?: ReturnType<typeof ToolParameters.prototype.toObject>;
                strict?: boolean;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.parameters != null) {
                data.parameters = this.parameters.toObject();
            }
            if (this.strict != null) {
                data.strict = this.strict;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.description.length)
                writer.writeString(2, this.description);
            if (this.has_parameters)
                writer.writeMessage(3, this.parameters, () => this.parameters.serialize(writer));
            if (this.strict != false)
                writer.writeBool(4, this.strict);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToolFunction {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToolFunction();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.description = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.parameters, () => message.parameters = ToolParameters.deserialize(reader));
                        break;
                    case 4:
                        message.strict = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToolFunction {
            return ToolFunction.deserialize(bytes);
        }
    }
    export class Tools extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            serverConfig?: ToolServerConfig;
            type?: string;
            function?: ToolFunction;
            messages?: ToolMessages[];
            headers?: ToolHeaders[];
            async?: boolean;
            createdAt?: number;
            updatedAt?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5, 6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("serverConfig" in data && data.serverConfig != undefined) {
                    this.serverConfig = data.serverConfig;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("function" in data && data.function != undefined) {
                    this.function = data.function;
                }
                if ("messages" in data && data.messages != undefined) {
                    this.messages = data.messages;
                }
                if ("headers" in data && data.headers != undefined) {
                    this.headers = data.headers;
                }
                if ("async" in data && data.async != undefined) {
                    this.async = data.async;
                }
                if ("createdAt" in data && data.createdAt != undefined) {
                    this.createdAt = data.createdAt;
                }
                if ("updatedAt" in data && data.updatedAt != undefined) {
                    this.updatedAt = data.updatedAt;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get serverConfig() {
            return pb_1.Message.getWrapperField(this, ToolServerConfig, 2) as ToolServerConfig;
        }
        set serverConfig(value: ToolServerConfig) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_serverConfig() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get function() {
            return pb_1.Message.getWrapperField(this, ToolFunction, 4) as ToolFunction;
        }
        set function(value: ToolFunction) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_function() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get messages() {
            return pb_1.Message.getRepeatedWrapperField(this, ToolMessages, 5) as ToolMessages[];
        }
        set messages(value: ToolMessages[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get headers() {
            return pb_1.Message.getRepeatedWrapperField(this, ToolHeaders, 6) as ToolHeaders[];
        }
        set headers(value: ToolHeaders[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get async() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set async(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        get createdAt() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set createdAt(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get updatedAt() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set updatedAt(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        static fromObject(data: {
            id?: string;
            serverConfig?: ReturnType<typeof ToolServerConfig.prototype.toObject>;
            type?: string;
            function?: ReturnType<typeof ToolFunction.prototype.toObject>;
            messages?: ReturnType<typeof ToolMessages.prototype.toObject>[];
            headers?: ReturnType<typeof ToolHeaders.prototype.toObject>[];
            async?: boolean;
            createdAt?: number;
            updatedAt?: number;
        }): Tools {
            const message = new Tools({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.serverConfig != null) {
                message.serverConfig = ToolServerConfig.fromObject(data.serverConfig);
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.function != null) {
                message.function = ToolFunction.fromObject(data.function);
            }
            if (data.messages != null) {
                message.messages = data.messages.map(item => ToolMessages.fromObject(item));
            }
            if (data.headers != null) {
                message.headers = data.headers.map(item => ToolHeaders.fromObject(item));
            }
            if (data.async != null) {
                message.async = data.async;
            }
            if (data.createdAt != null) {
                message.createdAt = data.createdAt;
            }
            if (data.updatedAt != null) {
                message.updatedAt = data.updatedAt;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                serverConfig?: ReturnType<typeof ToolServerConfig.prototype.toObject>;
                type?: string;
                function?: ReturnType<typeof ToolFunction.prototype.toObject>;
                messages?: ReturnType<typeof ToolMessages.prototype.toObject>[];
                headers?: ReturnType<typeof ToolHeaders.prototype.toObject>[];
                async?: boolean;
                createdAt?: number;
                updatedAt?: number;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.serverConfig != null) {
                data.serverConfig = this.serverConfig.toObject();
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.function != null) {
                data.function = this.function.toObject();
            }
            if (this.messages != null) {
                data.messages = this.messages.map((item: ToolMessages) => item.toObject());
            }
            if (this.headers != null) {
                data.headers = this.headers.map((item: ToolHeaders) => item.toObject());
            }
            if (this.async != null) {
                data.async = this.async;
            }
            if (this.createdAt != null) {
                data.createdAt = this.createdAt;
            }
            if (this.updatedAt != null) {
                data.updatedAt = this.updatedAt;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.has_serverConfig)
                writer.writeMessage(2, this.serverConfig, () => this.serverConfig.serialize(writer));
            if (this.type.length)
                writer.writeString(3, this.type);
            if (this.has_function)
                writer.writeMessage(4, this.function, () => this.function.serialize(writer));
            if (this.messages.length)
                writer.writeRepeatedMessage(5, this.messages, (item: ToolMessages) => item.serialize(writer));
            if (this.headers.length)
                writer.writeRepeatedMessage(6, this.headers, (item: ToolHeaders) => item.serialize(writer));
            if (this.async != false)
                writer.writeBool(7, this.async);
            if (this.createdAt != 0)
                writer.writeInt64(8, this.createdAt);
            if (this.updatedAt != 0)
                writer.writeInt64(9, this.updatedAt);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tools {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tools();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.serverConfig, () => message.serverConfig = ToolServerConfig.deserialize(reader));
                        break;
                    case 3:
                        message.type = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.function, () => message.function = ToolFunction.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.messages, () => pb_1.Message.addToRepeatedWrapperField(message, 5, ToolMessages.deserialize(reader), ToolMessages));
                        break;
                    case 6:
                        reader.readMessage(message.headers, () => pb_1.Message.addToRepeatedWrapperField(message, 6, ToolHeaders.deserialize(reader), ToolHeaders));
                        break;
                    case 7:
                        message.async = reader.readBool();
                        break;
                    case 8:
                        message.createdAt = reader.readInt64();
                        break;
                    case 9:
                        message.updatedAt = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tools {
            return Tools.deserialize(bytes);
        }
    }
    export class FetchToolsResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tools?: Tools[];
            success?: boolean;
            lastBasis?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tools" in data && data.tools != undefined) {
                    this.tools = data.tools;
                }
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("lastBasis" in data && data.lastBasis != undefined) {
                    this.lastBasis = data.lastBasis;
                }
            }
        }
        get tools() {
            return pb_1.Message.getRepeatedWrapperField(this, Tools, 1) as Tools[];
        }
        set tools(value: Tools[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get success() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get lastBasis() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set lastBasis(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            tools?: ReturnType<typeof Tools.prototype.toObject>[];
            success?: boolean;
            lastBasis?: number;
        }): FetchToolsResponse {
            const message = new FetchToolsResponse({});
            if (data.tools != null) {
                message.tools = data.tools.map(item => Tools.fromObject(item));
            }
            if (data.success != null) {
                message.success = data.success;
            }
            if (data.lastBasis != null) {
                message.lastBasis = data.lastBasis;
            }
            return message;
        }
        toObject() {
            const data: {
                tools?: ReturnType<typeof Tools.prototype.toObject>[];
                success?: boolean;
                lastBasis?: number;
            } = {};
            if (this.tools != null) {
                data.tools = this.tools.map((item: Tools) => item.toObject());
            }
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.lastBasis != null) {
                data.lastBasis = this.lastBasis;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tools.length)
                writer.writeRepeatedMessage(1, this.tools, (item: Tools) => item.serialize(writer));
            if (this.success != false)
                writer.writeBool(2, this.success);
            if (this.lastBasis != 0)
                writer.writeInt64(3, this.lastBasis);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FetchToolsResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FetchToolsResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.tools, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Tools.deserialize(reader), Tools));
                        break;
                    case 2:
                        message.success = reader.readBool();
                        break;
                    case 3:
                        message.lastBasis = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FetchToolsResponse {
            return FetchToolsResponse.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedToolServiceService {
        static definition = {
            createTool: {
                path: "/tmq.ToolService/createTool",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ToolRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ToolRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: dependency_1.tmq.DefaultResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => dependency_1.tmq.DefaultResponse.deserialize(new Uint8Array(bytes))
            },
            fetchTools: {
                path: "/tmq.ToolService/fetchTools",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: FetchToolsRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => FetchToolsRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: FetchToolsResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => FetchToolsResponse.deserialize(new Uint8Array(bytes))
            },
            updateTools: {
                path: "/tmq.ToolService/updateTools",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ToolRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ToolRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: dependency_1.tmq.DefaultResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => dependency_1.tmq.DefaultResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract createTool(call: grpc_1.ServerUnaryCall<ToolRequest, dependency_1.tmq.DefaultResponse>, callback: grpc_1.sendUnaryData<dependency_1.tmq.DefaultResponse>): void;
        abstract fetchTools(call: grpc_1.ServerUnaryCall<FetchToolsRequest, FetchToolsResponse>, callback: grpc_1.sendUnaryData<FetchToolsResponse>): void;
        abstract updateTools(call: grpc_1.ServerUnaryCall<ToolRequest, dependency_1.tmq.DefaultResponse>, callback: grpc_1.sendUnaryData<dependency_1.tmq.DefaultResponse>): void;
    }
    export class ToolServiceClient extends grpc_1.makeGenericClientConstructor(UnimplementedToolServiceService.definition, "ToolService", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        createTool: GrpcUnaryServiceInterface<ToolRequest, dependency_1.tmq.DefaultResponse> = (message: ToolRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<dependency_1.tmq.DefaultResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<dependency_1.tmq.DefaultResponse>, callback?: grpc_1.requestCallback<dependency_1.tmq.DefaultResponse>): grpc_1.ClientUnaryCall => {
            return super.createTool(message, metadata, options, callback);
        };
        fetchTools: GrpcUnaryServiceInterface<FetchToolsRequest, FetchToolsResponse> = (message: FetchToolsRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<FetchToolsResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<FetchToolsResponse>, callback?: grpc_1.requestCallback<FetchToolsResponse>): grpc_1.ClientUnaryCall => {
            return super.fetchTools(message, metadata, options, callback);
        };
        updateTools: GrpcUnaryServiceInterface<ToolRequest, dependency_1.tmq.DefaultResponse> = (message: ToolRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<dependency_1.tmq.DefaultResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<dependency_1.tmq.DefaultResponse>, callback?: grpc_1.requestCallback<dependency_1.tmq.DefaultResponse>): grpc_1.ClientUnaryCall => {
            return super.updateTools(message, metadata, options, callback);
        };
    }
}
